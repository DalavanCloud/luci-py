<!--
  Copyright 2016 The LUCI Authors. All rights reserved.
  Use of this source code is governed under the Apache License, Version 2.0
  that can be found in the LICENSE file.

  window.SwarmingBehaviors.BotListBehavior contains any shared functions and
  constants used by the bot-list and its sub-elements.

  To use it, include
      behaviors: [SwarmingBehaviors.BotListBehavior]
  in the creation of your Polymer element.
-->
<script>

  window.SwarmingBehaviors = window.SwarmingBehaviors || {};
  (function(){
    var ANDROID_ALIASES = {
      "bullhead": "Nexus 5X",
      "flo": "Nexus 7",
      "flounder": "Nexus 9",
      "hammerhead": "Nexus 5",
      "mako": "Nexus 4",
      "shamu": "Nexus 6",
    };
    // Taken from http://developer.android.com/reference/android/os/BatteryManager.html
    var BATTERY_HEALTH_UNKNOWN = 1;
    var BATTERY_HEALTH_GOOD = 2;
    var BATTERY_STATUS_CHARGING = 2;

    var UNAUTHENTICATED = "unauthenticated";
    var AVAILABLE = "available";
    var UNKNOWN = "unknown";

    var GPU_ALIASES = {
      "1002": "AMD",
      "1002:6779": "AMD Radeon HD 6450/7450/8450",
      "1002:6821": "AMD Radeon HD 8870M",
      "1002:9830": "AMD Radeon HD 8400",
      "102b":      "Matrox",
      "102b:0522": "Matrox MGA G200e",
      "102b:0532": "Matrox MGA G200eW",
      "102b:0534": "Matrox G200eR2",
      "10de":      "NVIDIA",
      "10de:08aa": "NVIDIA GeForce 320M",
      "10de:0fe9": "NVIDIA GeForce GT 750M Mac Edition",
      "10de:104a": "NVIDIA GeForce GT 610",
      "10de:11c0": "NVIDIA GeForce GTX 660",
      "10de:1244": "NVIDIA GeForce GTX 550 Ti",
      "10de:1401": "NVIDIA GeForce GTX 960",
      "8086":      "Intel",
      "8086:041a": "Intel Xeon Integrated",
      "8086:0a2e": "Intel Haswell Integrated",
      "8086:0d26": "Intel Crystal Well Integrated",
    }

    // For consistency, all aliases are displayed like:
    // Nexus 5X (bullhead)
    // This regex matches a string like "ALIAS (ORIG)", with ORIG as group 1.
    var ALIAS_REGEXP = /.+ \((.*)\)/;

    // This behavior wraps up all the shared bot-list functionality.
    SwarmingBehaviors.BotListBehavior = {

      properties: {
        // TODO(kjlubick): Add more of these things from state, as they
        // needed/useful/requested.
        DIMENSIONS: {
          type: Array,
          value: function(){
            return ["android_devices", "cores", "cpu", "device_type",
                "device_os", "gpu", "id", "os", "pool"];
          },
        },
        DIMENSIONS_WITH_ALIASES: {
          type: Array,
          value: function(){
            return ["device_type", "gpu"];
          },
        },
        BOT_PROPERTIES: {
          type: Array,
          value: function() {
            return ["disk_space", "task", "status"];
          }
        },
      },

      _androidAlias: function(dt) {
        return ANDROID_ALIASES[dt] || UNKNOWN;
      },

      // _applyAlias is the consistent way to modify a string to show its alias.
      _applyAlias: function(orig, alias) {
        return alias +" ("+orig+")";
      },

      // _attribute looks first in dimension and then in state for the
      // specified attribute. This will always return an array. If there is
      // no matching attribute, ["unknown"] will be returned.
      _attribute: function(bot, attr, none) {
        none = none || UNKNOWN;
        return this._dimension(bot, attr) || this._state(bot, attr) || [none];
      },

      _devices: function(bot) {
        var devices = [];
        var d = (bot && bot.state && bot.state.devices) || {};
        // state.devices is like {Serial:Object}, so we need to keep the serial
        for (key in d) {
          var o = d[key];
          o.serial = key;
          o.okay = (o.state === AVAILABLE);
          devices.push(o);
        }
        return devices;
      },

      // _deviceType returns the codename of a given Android device.
      _deviceType: function(device) {
        if (!device || !device.build) {
          return UNKNOWN;
        }
        var t = device.build["build.product"] || device.build["product.board"] ||
                device.build["product.device"] || UNKNOWN;
        return t.toLowerCase();
      },

      // _dimension returns the given dimension of a bot. If it is defined, it
      // is an array of strings.
      _dimension: function(bot, dim) {
        if (!bot || !bot.dimensions || !dim) {
          return undefined;
        }
        for (var i = 0; i < bot.dimensions.length; i++) {
          if (bot.dimensions[i].key === dim) {
            return bot.dimensions[i].value;
          }
        }
        return undefined;
      },

      _gpuAlias: function(gpu) {
        return GPU_ALIASES[gpu] || UNKNOWN;
      },

      _not: function(a) {
        return !a;
      },

      _or: function() {
        var result = false;
        // can't use .foreach, as arguments isn't really a function.
        for (var i = 0; i < arguments.length; i++) {
          result = result || arguments[i];
        }
        return result;
      },

      // _state returns the requested attribute from a bot's state.
      // For consistency with _dimension, if the attribute is not an array,
      // it is put as the only element in an array.
      _state: function(bot, attr) {
        if (!bot || !bot.state || !bot.state[attr]) {
          return undefined
        }
        var state = bot.state[attr];
        if (Array.isArray(state)) {
          return state;
        }
        return [state];
      },

      _taskId: function(bot) {
        if (bot && bot.task_id) {
          return bot.task_id;
        }
        return "idle";
      },

      // _unalias will return the base dimension/state with its alias removed
      // if it had one.  This is handy for sorting and filtering.
      _unalias: function(str) {
        var match = ALIAS_REGEXP.exec(str);
        if (match) {
          return match[1];
        }
        return str;
      },
    }
  })()
</script>
