<!--
  Copyright 2016 The LUCI Authors. All rights reserved.
  Use of this source code is governed under the Apache License, Version 2.0
  that can be found in the LICENSE file.

  This in an HTML Import-able file that contains the definition
  of the following elements:

    <bot-list>

  bot-list creats a dynamic table for viewing swarming bots.  Columns can be
  dynamically filtered and it supports client-side filtering.

  This is a top-level element.

  Properties:
    client_id: String, will be set by server-side template evaluation.

  Methods:
    None.

  Events:
    None.
-->

<link rel="import" href="/res/imp/bower_components/iron-flex-layout/iron-flex-layout-classes.html">
<link rel="import" href="/res/imp/bower_components/polymer/polymer.html">

<link rel="import" href="/res/imp/common/sort-toggle.html">
<link rel="import" href="/res/imp/common/swarming-app.html">
<link rel="import" href="/res/imp/common/url-param.html">

<link rel="import" href="bot-filters.html">
<link rel="import" href="bot-list-data.html">
<link rel="import" href="bot-list-shared.html">
<link rel="import" href="bot-list-summary.html">

<dom-module id="bot-list">
  <template>
    <style include="iron-flex iron-flex-alignment iron-positioning swarming-app-style">
      bot-filters, bot-list-summary {
        margin-bottom: 8px;
        margin-right: 10px;
      }
      .bot {
        margin:5px;
        max-width:400px;
        min-height:100px;
        min-width:300px;
      }
      table {
        border-collapse: collapse;
        margin-left: 5px;
      }
      td, th {
        border: 1px solid #DDD;
        padding: 5px;
      }

      .quarantined, .bad-device {
        background-color: #ffdddd;
      }
      .dead {
        background-color: #cccccc;
      }

      th {
        position: relative;
      }
      sort-toggle {
        position: absolute;
        right: 0;
        top: 0.4em;
      }
      .bot-list th > span {
        /* Leave space for sort-toggle*/
        padding-right: 30px;
      }
    </style>

    <url-param name="sort"
      value="{{_sortstr}}"
      default_value="id:asc">
    </url-param>

    <swarming-app
      client_id="[[client_id]]"
      auth_headers="{{_auth_headers}}"
      signed_in="{{_signed_in}}"

      busy="[[_busy]]"
      name="Swarming Bot List">

      <h2 hidden$="[[_signed_in]]">You must sign in to see anything useful.</h2>

      <div hidden$="[[_not(_signed_in)]]">

        <div class="horizontal layout">

          <bot-filters
            dimensions="[[_dimensions]]"
            primary_map="[[_primary_map]]"
            primary_arr="[[_primary_arr]]"

            columns="{{_columns}}"
            query_params="{{_query_params}}"
            filter="{{_filter}}"
            verbose="{{_verbose}}">
          </bot-filters>

          <bot-list-summary
            columns="[[_columns]]"
            fleet="[[_fleet]]"
            filtered_bots="[[_filteredSortedBots]]"
            sort="[[_sortstr]]"
            verbose="[[_verbose]]">
          </bot-list-summary>

        </div>

        <bot-list-data
          auth_headers="[[_auth_headers]]"
          query_params="[[_query_params]]"

          bots="{{_bots}}"
          busy="{{_busy}}"
          dimensions="{{_dimensions}}"
          fleet="{{_fleet}}"
          primary_map="{{_primary_map}}"
          primary_arr="{{_primary_arr}}">
        </bot-list-data>

        <table class="bot-list">
          <thead on-sort_change="_sortChange">
          <!-- To allow for dynamic columns without having a lot of copy-pasted
          code, we break columns up into "special" and "plain" columns. Special
          columns require some sort of HTML output (e.g. anchor tags) and plain
          columns just output text.  The plain columns use Polymer functions to
          insert their text [_header(), _column(), _deviceColumn()].  Polymer
          functions do not allow HTML (to avoid XSS), so special columns, like id
          and task are inserted in a fixed order.
          -->
            <tr>
              <th>
                <span>Bot Id</span>
                <sort-toggle
                    name="id"
                    current="[[_sort]]">
                </sort-toggle>
              </th>
              <!-- This wonky syntax is the proper way to listen to changes on an
              array (we are listening to all subproperties). The element returned is
              not of much use, so we'll ignore it in _hide() and use this._columns.
              -->
              <th hidden$="[[_hide('task', _columns.*)]]">
                <span>Current Task</span>
                <sort-toggle
                    name="task"
                    current="[[_sort]]">
                </sort-toggle>
              </th>

              <template is="dom-repeat"
                    items="[[_plain_columns]]"
                    as="c">
                <th hidden$="[[_hide(c)]]">
                  <span>[[_header(c)]]</span>
                  <sort-toggle
                      name="[[c]]"
                      current="[[_sort]]">
                  </sort-toggle>
                </th>
              </template>
            </tr>
          </thead>
          <tbody>
            <template id="bot_table" is="dom-repeat"
                  items="[[_filteredSortedBots]]"
                  as="bot"
                  initial-count=50>

              <tr class$="[[_botClass(bot)]]">
                <td>
                  <a class="center"
                     href$="[[_botLink(bot.bot_id)]]"
                     target="_blank">
                     [[bot.bot_id]]
                  </a>
                </td>
                <td hidden$="[[_hide('task', _columns.*)]]">
                  <a href$="[[_taskLink(bot)]]">[[_taskId(bot)]]</a>
                </td>

                <template is="dom-repeat"
                      items="[[_plain_columns]]"
                      as="c">
                  <td hidden$="[[_hide(c)]]">
                    [[_column(c, bot, _verbose)]]
                  </td>
                </template>

              </tr>
              <template is="dom-repeat"
                    items="[[_devices(bot)]]"
                    as="device">
                <tr hidden$="[[_hide('android_devices', _columns.*)]]"
                    class$="[[_deviceClass(device)]]">
                  <td></td>
                  <td hidden$="[[_hide('task', _columns.*)]]"></td>
                  <template is="dom-repeat"
                        items="[[_plain_columns]]"
                        as="c">
                    <td hidden$="[[_hide(c)]]">
                      [[_deviceColumn(c, device, _verbose)]]
                    </td>
                  </template>
                </tr>
              </template> <!--devices repeat-->
            </template> <!--bot-table repeat-->
          </tbody>
        </table>
      </div>

    </swarming-app>

  </template>
  <script>
  (function(){
    var special_columns = ["id", "task"];

    var headerMap = {
      // "id" and "task" are special, so they don't go here and have their
      // headers hard-coded below.
      "android_devices": "Android Devices",
      "cores": "Cores",
      "cpu": "CPU",
      "device": "Non-android Device",
      "device_os": "Device OS",
      "device_type": "Device Type",
      "disk_space": "Free Space (MB)",
      "gpu": "GPU",
      "os": "OS",
      "pool": "Pool",
      "status": "Status",
      "xcode_version": "XCode Version",
    };

    // This maps column name to a function that will return the content for a
    // given bot. These functions are bound to this element, and have access
    // to all functions defined here and in bot-list-shared. If a column
    // is not listed here, a sane default will be used (see _column()).
    var columnMap = {
      android_devices: function(bot) {
        var devs = this._attribute(bot, "android_devices", "0");
        if (this._verbose) {
          return devs.join(" | ") + " devices available";
        }
        // max() works on strings as long as they can be coerced to Number.
        return Math.max(...devs) + " devices available";
      },
      device_type: function(bot) {
        var dt = this._attribute(bot, "device_type", "none");
        dt = dt[0];
        var alias = this._androidAlias(dt);
        if (alias === "unknown") {
          return dt;
        }
        return this._applyAlias(dt, alias);
      },
      disk_space: function(bot) {
        var aliased = [];
        bot.disks.forEach(function(disk){
          var alias = sk.human.bytes(disk.mb, swarming.MB);
          aliased.push(this._applyAlias(disk.mb, disk.id + " "+ alias));
        }.bind(this));
        if (this._verbose) {
          return aliased.join(" | ");
        }
        return aliased[0];
      },
      gpu: function(bot){
        var gpus = this._attribute(bot, "gpu", "none")
        var verbose = []
        var named = [];
        // non-verbose mode has only the top level GPU info "e.g. NVidia"
        // which is found by looking for gpu ids w/o a colon.
        gpus.forEach(function(g){
          var alias = this._gpuAlias(g);
          if (alias === "unknown") {
            verbose.push(g);
            if (g.indexOf(":") === -1) {
              named.push(g);
            }
            return;
          }
          verbose.push(this._applyAlias(g, alias));
          if (g.indexOf(":") === -1) {
            named.push(this._applyAlias(g, alias));
          }
        }.bind(this))
        if (this._verbose) {
          return verbose.join(" | ");
        }
        return named.join(" | ");
      },
      id: function(bot) {
        return bot.bot_id;
      },
      pool: function(bot) {
        var pool = this._attribute(bot, "pool");
        return pool.join(" | ");
      },
      status: function(bot) {
        // If a bot is both dead and quarantined, show the deadness over the
        // quarentinedness.
        if (bot.is_dead) {
          return "Dead.  Last seen " + sk.human.diffDate(bot.last_seen_ts) +
              " ago";
        }
        if (bot.quarantined) {
          return "Quarantined: " + this._attribute(bot, "quarantined");
        }
        return "Alive";
      },
      task: function(bot){
        return this._taskId(bot);
      },
    };

    var deviceColumnMap = {
      android_devices: function(device) {
        var str = this._androidAliasDevice(device);
        if (device.okay) {
          str = this._applyAlias(this._deviceType(device), str);
        }
        str += " S/N:";
        str += device.serial;
        return str;
      },
      device_os: function(device) {
        if (device.build) {
          return device.build["build.id"];
        }
        return "unknown";
      },
      status: function(device) {
        return device.state;
      }
    }

    // specialSort defines any custom sorting rules. By default, a
    // naturalCompare of the column content is done.
    var specialSort = {
      android_devices: function(dir, botA, botB) {
        // We sort on the number of attached devices. Note that this
        // may not be the same as android_devices, because _devices().length
        // counts all devices plugged into the bot, whereas android_devices
        // counts just devices ready for work.
        var botACol = this._devices(botA).length;
        var botBCol = this._devices(botB).length;
        return dir * swarming.naturalCompare(botACol, botBCol);
      },
      disk_space: function(dir, botA, botB) {
        // We sort based on the raw number of MB of the first disk.
        var botACol = botA.disks[0].mb;
        var botBCol = botB.disks[0].mb;;
        return dir * swarming.naturalCompare(botACol, botBCol);
      },
    };

    Polymer({
      is: 'bot-list',
      behaviors: [SwarmingBehaviors.BotListBehavior],

      properties: {

        client_id: {
          type: String,
        },

        _bots: {
          type: Array,
        },

        _columns: {
          type: Array,
        },

        _filter: {
          type: Function,
          value: function() {
            return true;
          },
        },

        _filteredSortedBots: {
          type: Array,
          computed: "_filterAndSort(_bots,_filter.*,_sort.*)"
        },

        _plain_columns: {
          type: Array,
          computed: "_stripSpecial(_columns.*)",
        },

        // _sort is an Object {name:String, direction:String}.
        _sort: {
          type: Object,
          computed: "_makeObject(_sortstr)",
        },

        _verbose: {
          type: Boolean,
        }
      },

      _botClass: function(bot) {
        if (bot.is_dead) {
          return "dead";
        }
        if (bot.quarantined) {
          return "quarantined";
        }
        return "";
      },

      _botLink: function(id) {
        // TODO(kjlubick) Make this point to /newui/ when appropriate.
        return "/restricted/bot/"+id;
      },


      _column: function(col, bot) {
        var f = columnMap[col];
        if (!f) {
          f = function(bot) {
            var c = this._attribute(bot, col, "none");
            if (this._verbose) {
              return c.join(" | ");
            }
            return c[0];
          }
        }
        return f.bind(this)(bot);
      },

      _androidAliasDevice: function(device) {
        if (device.notReady) {
          return UNAUTHENTICATED.toUpperCase();
        }
        return this._androidAlias(this._deviceType(device));
      },

      _deviceColumn: function(col, device) {
        var f = deviceColumnMap[col];
        if (!f || !device) {
          return "";
        }
        return f.bind(this)(device);
      },

      _deviceClass: function(device) {
        if (!device.okay) {
          return "bad-device";
        }
        return "";
      },

      _filterAndSort: function(a,b,c) {
        // We intentionally sort this._bots (and not a copy) to allow users to
        // "chain" sorts, that is, sort by one thing and then another, and
        // have both orderings properly impact the list.
        swarming.stableSort(this._bots, this._sortBotTable.bind(this));
        var bots = this._bots;
        if (this._filter) {
          bots = bots.filter(this._filter.bind(this));
        }

        return bots;
      },

      _header: function(col){
        return headerMap[col] || col;
      },

      _hide: function(col) {
        return this._columns.indexOf(col) === -1;
      },

      _makeObject: function(sortstr){
        if (!sortstr) {
          return undefined;
        }
        var pieces = sortstr.split(":");
        if (pieces.length != 2) {
          // fail safe
          return {name: "id", direction:"desc"};
        }
        return {
          name: pieces[0],
          direction: pieces[1],
        }
      },

      _reRender: function(filter, sort) {
        this.$.bot_table.render();
      },

      _sortBotTable: function(botA, botB) {
        if (!this._sort) {
          return 0;
        }
        var dir = 1;
        if (this._sort.direction === "desc") {
          dir = -1;
        }
        var sort = specialSort[this._sort.name];
        if (sort) {
          return sort.bind(this)(dir, botA, botB);
        }
        // Default to a natural compare of the columns.
        var botACol = this._column(this._sort.name, botA);
        var botBCol = this._column(this._sort.name, botB);

        return dir * swarming.naturalCompare(botACol, botBCol);
      },

      _sortChange: function(e) {
        // The event we get from sort-toggle tells us the name of what needs
        // to be sorting and how to sort it.
        if (!(e && e.detail && e.detail.name)) {
          return;
        }
        // should trigger the computation of _sort and __filterAndSort
        this.set("_sortstr", e.detail.name +":"+e.detail.direction);
      },

      // _stripSpecial removes the special columns and sorts the remaining
      // columns so they always appear in the same order, regardless of
      // the order they are added.
      _stripSpecial: function(){
        return this._columns.filter(function(c){
          return special_columns.indexOf(c) === -1;
        }).sort();
      },

      _taskLink: function(data) {
        if (data && data.task_id) {
          return "/user/task/" + data.task_id;
        }
        return undefined;
      }

    });
  })();
  </script>
</dom-module>