<!--
  Copyright 2016 The LUCI Authors. All rights reserved.
  Use of this source code is governed under the Apache License, Version 2.0
  that can be found in the LICENSE file.

  This in an HTML Import-able file that contains the definition
  of the following elements:

    <bot-list>

  bot-list creats a dynamic table for viewing swarming bots.  Columns can be
  dynamically filtered and it supports client-side filtering.

  This is a top-level element.

  Properties:
    client_id: String, Oauth 2.0 client id.  It will be set by server-side
        template evaluation.

  Methods:
    None.

  Events:
    None.
-->

<link rel="import" href="/res/imp/bower_components/iron-flex-layout/iron-flex-layout-classes.html">
<link rel="import" href="/res/imp/bower_components/polymer/polymer.html">

<link rel="import" href="/res/imp/common/dynamic-table.html">
<link rel="import" href="/res/imp/common/sort-toggle.html">
<link rel="import" href="/res/imp/common/swarming-app.html">
<link rel="import" href="/res/imp/common/url-param.html">

<link rel="import" href="bot-filters.html">
<link rel="import" href="bot-list-data.html">
<link rel="import" href="bot-list-shared.html">
<link rel="import" href="bot-list-summary.html">

<dom-module id="bot-list">
  <template>
    <style include="iron-flex iron-flex-alignment iron-positioning swarming-app-style dynamic-table-style">
      bot-filters, bot-list-summary {
        margin-bottom: 8px;
        margin-right: 10px;
      }
      .quarantined, .bad-device {
        background-color: #ffdddd;
      }
      .dead {
        background-color: #cccccc;
      }
      .bot-list th > span {
        /* Leave space for sort-toggle*/
        padding-right: 30px;
      }
    </style>

    <url-param name="sort"
      value="{{_sortstr}}"
      default_value="id:asc">
    </url-param>

    <swarming-app
      client_id="[[client_id]]"
      auth_headers="{{_auth_headers}}"
      signed_in="{{_signed_in}}"

      busy="[[_busy]]"
      name="Swarming Bot List">

      <h2 hidden$="[[_signed_in]]">You must sign in to see anything useful.</h2>

      <div hidden$="[[_not(_signed_in)]]">

        <div class="horizontal layout">

          <bot-filters
            dimensions="[[_dimensions]]"
            primary_map="[[_primary_map]]"
            primary_arr="[[_primary_arr]]"

            columns="{{_columns}}"
            query_params="{{_query_params}}"
            filter="{{_filter}}"
            verbose="{{_verbose}}">
          </bot-filters>

          <bot-list-summary
            columns="[[_columns]]"
            fleet="[[_fleet]]"
            filtered_bots="[[_filteredSortedItems]]"
            sort="[[_sortstr]]"
            verbose="[[_verbose]]">
          </bot-list-summary>

        </div>

        <bot-list-data
          auth_headers="[[_auth_headers]]"
          query_params="[[_query_params]]"

          bots="{{_items}}"
          busy="{{_busy}}"
          dimensions="{{_dimensions}}"
          fleet="{{_fleet}}"
          primary_map="{{_primary_map}}"
          primary_arr="{{_primary_arr}}">
        </bot-list-data>

        <table class="bot-list">
          <thead on-sort_change="_sortChange">
          <!-- To allow for dynamic columns without having a lot of copy-pasted
          code, we break columns up into "special" and "plain" columns. Special
          columns require some sort of HTML output (e.g. anchor tags) and plain
          columns just output text.  The plain columns use Polymer functions to
          insert their text [_header(), _column(), _deviceColumn()].  Polymer
          functions do not allow HTML (to avoid XSS), so special columns, like id
          and task are inserted in a fixed order.
          -->
            <tr>
              <th>
                <span>Bot Id</span>
                <sort-toggle
                    name="id"
                    current="[[_sort]]">
                </sort-toggle>
              </th>
              <!-- This wonky syntax is the proper way to listen to changes on an
              array (we are listening to all subproperties). The element returned is
              not of much use, so we'll ignore it in _hide() and use this._columns.
              -->
              <th hidden$="[[_hide('task', _columns.*)]]">
                <span>Current Task</span>
                <sort-toggle
                    name="task"
                    current="[[_sort]]">
                </sort-toggle>
              </th>

              <template
                  is="dom-repeat"
                  items="[[_plainColumns]]"
                  as="c">
                <th hidden$="[[_hide(c)]]">
                  <span>[[_header(c)]]</span>
                  <sort-toggle
                      name="[[c]]"
                      current="[[_sort]]">
                  </sort-toggle>
                </th>
              </template>
            </tr>
          </thead>
          <tbody>
            <template
                id="bot_table"
                is="dom-repeat"
                items="[[_filteredSortedItems]]"
                as="bot"
                initial-count=50>

              <tr class$="[[_botClass(bot)]]">
                <td>
                  <a
                      class="center"
                      href$="[[_botLink(bot.bot_id)]]"
                      target="_blank">
                      [[bot.bot_id]]
                  </a>
                </td>
                <td hidden$="[[_hide('task', _columns.*)]]">
                  <a href$="[[_taskLink(bot)]]">[[_taskId(bot)]]</a>
                </td>

                <template
                    is="dom-repeat"
                    items="[[_plainColumns]]"
                    as="c">
                  <td hidden$="[[_hide(c)]]">
                    [[_column(c, bot, _verbose)]]
                  </td>
                </template>

              </tr>
              <template
                  is="dom-repeat"
                  items="[[_devices(bot)]]"
                  as="device">
                <tr
                    hidden$="[[_hide('android_devices', _columns.*)]]"
                    class$="[[_deviceClass(device)]]">
                  <td></td>
                  <td hidden$="[[_hide('task', _columns.*)]]"></td>
                  <template
                      is="dom-repeat"
                      items="[[_plainColumns]]"
                      as="c">
                    <td hidden$="[[_hide(c)]]">
                      [[_deviceColumn(c, device, _verbose)]]
                    </td>
                  </template>
                </tr>
              </template> <!--devices repeat-->
            </template> <!--bot-table repeat-->
          </tbody>
        </table>
      </div>

    </swarming-app>

  </template>
  <script>
  (function(){
    // see dynamic-table for more information on specialColumns, headerMap,
    // columnMap, and specialSort
    var specialColumns = ["id", "task"];

    var headerMap = {
      // "id" and "task" are special, so they don't go here. They have their
      // headers hard-coded above.
      "android_devices": "Android Devices",
      "cores": "Cores",
      "cpu": "CPU",
      "device": "Non-android Device",
      "device_os": "Device OS",
      "device_type": "Device Type",
      "disk_space": "Free Space (MB)",
      "gpu": "GPU",
      "os": "OS",
      "pool": "Pool",
      "status": "Status",
      "xcode_version": "XCode Version",
    };

    var columnMap = {
      android_devices: function(bot) {
        var devs = this._attribute(bot, "android_devices", "0");
        if (this._verbose) {
          return devs.join(" | ") + " devices available";
        }
        // max() works on strings as long as they can be coerced to Number.
        return Math.max(...devs) + " devices available";
      },
      device_type: function(bot) {
        var dt = this._attribute(bot, "device_type", "none");
        dt = dt[0];
        var alias = this._androidAlias(dt);
        if (alias === "unknown") {
          return dt;
        }
        return this._applyAlias(dt, alias);
      },
      disk_space: function(bot) {
        var aliased = [];
        bot.disks.forEach(function(disk){
          var alias = sk.human.bytes(disk.mb, swarming.MB);
          aliased.push(this._applyAlias(disk.mb, disk.id + " "+ alias));
        }.bind(this));
        if (this._verbose) {
          return aliased.join(" | ");
        }
        return aliased[0];
      },
      gpu: function(bot){
        var gpus = this._attribute(bot, "gpu", "none")
        var verbose = []
        var named = [];
        // non-verbose mode has only the top level GPU info "e.g. NVidia"
        // which is found by looking for gpu ids w/o a colon.
        gpus.forEach(function(g){
          var alias = this._gpuAlias(g);
          if (alias === "unknown") {
            verbose.push(g);
            if (g.indexOf(":") === -1) {
              named.push(g);
            }
            return;
          }
          verbose.push(this._applyAlias(g, alias));
          if (g.indexOf(":") === -1) {
            named.push(this._applyAlias(g, alias));
          }
        }.bind(this))
        if (this._verbose) {
          return verbose.join(" | ");
        }
        return named.join(" | ");
      },
      id: function(bot) {
        return bot.bot_id;
      },
      pool: function(bot) {
        var pool = this._attribute(bot, "pool");
        return pool.join(" | ");
      },
      status: function(bot) {
        // If a bot is both dead and quarantined, show the deadness over the
        // quarentinedness.
        if (bot.is_dead) {
          return "Dead.  Last seen " + sk.human.diffDate(bot.last_seen_ts) +
              " ago";
        }
        if (bot.quarantined) {
          return "Quarantined: " + this._attribute(bot, "quarantined");
        }
        return "Alive";
      },
      task: function(bot){
        return this._taskId(bot);
      },
    };

    var deviceColumnMap = {
      android_devices: function(device) {
        var str = this._androidAliasDevice(device);
        if (device.okay) {
          str = this._applyAlias(this._deviceType(device), str);
        }
        str += " S/N:";
        str += device.serial;
        return str;
      },
      device_os: function(device) {
        if (device.build) {
          return device.build["build.id"];
        }
        return "unknown";
      },
      status: function(device) {
        return device.state;
      }
    }

    var specialSort = {
      android_devices: function(dir, botA, botB) {
        // We sort on the number of attached devices. Note that this
        // may not be the same as android_devices, because _devices().length
        // counts all devices plugged into the bot, whereas android_devices
        // counts just devices ready for work.
        var botACol = this._devices(botA).length;
        var botBCol = this._devices(botB).length;
        return dir * swarming.naturalCompare(botACol, botBCol);
      },
      disk_space: function(dir, botA, botB) {
        // We sort based on the raw number of MB of the first disk.
        var botACol = botA.disks[0].mb;
        var botBCol = botB.disks[0].mb;;
        return dir * swarming.naturalCompare(botACol, botBCol);
      },
    };

    Polymer({
      is: 'bot-list',
      behaviors: [SwarmingBehaviors.BotListBehavior,
                  SwarmingBehaviors.DynamicTableBehavior],

      properties: {
        client_id: {
          type: String,
        },

        // For dynamic table.
        _columnMap: {
          type: Object,
          value: columnMap,
        },
        _headerMap: {
          type: Object,
          value: headerMap,
        },
        _specialColumns: {
          type: Array,
          value: specialColumns,
        },
        _specialSort: {
          type: Object,
          value: specialSort,
        },

      },

      _botClass: function(bot) {
        if (bot.is_dead) {
          return "dead";
        }
        if (bot.quarantined) {
          return "quarantined";
        }
        return "";
      },

      _botLink: function(id) {
        // TODO(kjlubick) Make this point to /newui/ when appropriate.
        return "/restricted/bot/"+id;
      },


      _androidAliasDevice: function(device) {
        if (device.notReady) {
          return UNAUTHENTICATED.toUpperCase();
        }
        return this._androidAlias(this._deviceType(device));
      },

      _deviceColumn: function(col, device) {
        var f = deviceColumnMap[col];
        if (!f || !device) {
          return "";
        }
        return f.bind(this)(device);
      },

      _deviceClass: function(device) {
        if (!device.okay) {
          return "bad-device";
        }
        return "";
      },

      _taskLink: function(data) {
        if (data && data.task_id) {
          return "/user/task/" + data.task_id;
        }
        return undefined;
      }

    });
  })();
  </script>
</dom-module>