<!--
  Copyright 2016 The LUCI Authors. All rights reserved.
  Use of this source code is governed under the Apache License, Version 2.0
  that can be found in the LICENSE file.

  This in an HTML Import-able file that contains the definition
  of the following elements:

    <task-page-data>

  This makes calls authenticated with Oauth 2 to the swarming apis.  It parses
  that data into usable data structures.

  Properties:
    // input
    auth_headers: Object, the OAuth2 header to include in the request.  This
        should come from swarming-app.
    task_id: String, the id of the task to fetch data on.
    // output
    busy: Boolean, if we are fetching any data from the server.
    request: Object, the task request. This contains information such as the
       name, id, created_ts, tags, and dimensions.  See the sample data in
       task-request-demo.json for a full rundown.
    result: Object, the result or progress of the task. This contains information such as the
       modified_ts, duration, exit_code, information about the bot that picked
       up the task, etc.  See the sample data in task-result-demo.json for a
       full rundown.
    stdout: String, the raw output of the task, if any.  See
        task-stdout-demo.json for a full rundown.

  Methods:
    request(): Force a fetch of the data. This happens automatically when
        auth_headers is set or task_id is changed.

  Events:
    None.
-->


<link rel="import" href="/res/imp/common/common-behavior.html">
<link rel="import" href="/res/imp/common/task-behavior.html">

<dom-module id="task-page-data">
  <script>
  (function(){
    // Time to wait before requesting a new task. This is to allow a user to
    // type in a name and not have it make one set of requests for each
    // keystroke.
    var TASK_ID_DEBOUNCE_MS = 400;
    var lastRequest;

    var TIMES = ["abandoned_ts", "completed_ts", "created_ts", "modified_ts", "started_ts"];

    Polymer({
      is: 'task-page-data',

      behaviors: [
          SwarmingBehaviors.CommonBehavior,
          SwarmingBehaviors.TaskBehavior,
      ],

      properties: {
        // inputs
        auth_headers: {
          type: Object,
        },
        task_id: {
          type: String,
        },

        // outputs
        busy: {
          type: Boolean,
          computed: "_or(_busy1,_busy2,_busy3)",
          notify: true,
        },
        request: {
          type: Object,
          computed: "_parseRequest(_request)",
          notify: true,
        },
        result: {
          type: Object,
          computed: "_parseResult(_result)",
          notify: true,
        },
        stdout: {
          type: String,
          computed: "_parseStdout(_stdout)",
          notify: true,
        },

        // private
         _busy1: {
          type: Boolean,
          value: false
        },
        _busy2: {
          type: Boolean,
          value: false
        },
        _busy3: {
          type: Boolean,
          value: false
        },
        _request: {
          type: Object,
        },
        _result: {
          type: Object,
        },
        _stdout: {
          type: Object,
        },
      },

      observers: [
        "reload(auth_headers,task_id)",
      ],

      reload: function(){
        if (!this.task_id || !this.auth_headers) {
          console.log("task_id and auth_headers can't be empty");
          return;
        }
        if (lastRequest) {
          this.cancelAsync(lastRequest);
        }

        lastRequest = this.async(function(){
          lastRequest = undefined;
          var baseUrl = "/_ah/api/swarming/v1/task/"+this.task_id;
          this._getJsonAsync("_request", baseUrl + "/request",
            "_busy1", this.auth_headers);
          this._getJsonAsync("_result",
            baseUrl + "/result?include_performance_stats=true",
            "_busy2", this.auth_headers);
          this._getJsonAsync("_stdout", baseUrl + "/stdout",
            "_busy3", this.auth_headers);
        }, TASK_ID_DEBOUNCE_MS);
      },

      _parseRequest: function(request) {
        if (!request) {
          return {};
        }
        request.tagMap = {};
        request.tags = request.tags || [];
        request.tags.forEach(function(tag) {
          var split = tag.split(":", 1)
          var key = split[0];
          var rest = tag.substring(key.length + 1);
          request.tagMap[key] = rest;
        });

        TIMES.forEach(function(time) {
          if (request[time]) {
            request[time] = new Date(request[time]);
            request["human_"+time] = sk.human.localeTime(request[time]);
          }
        });
        // request.properties.dimensions
        request.properties = request.properties || {};
        if (request.properties.dimensions) {
          request.properties.dimensions.forEach(function(dim){
            if (swarming.alias.has(dim.key)) {
              dim.value = swarming.alias.apply(dim.value, dim.key);
            }
          })
        }
        return request;
      },

      _parseResult: function(result) {
        if (!result) {
          return {};
        }
        var now = new Date();
        TIMES.forEach(function(time) {
          if (result[time]) {
            result[time] = new Date(result[time]);
            result["human_"+time] = sk.human.localeTime(result[time]);
          }
        });
        // Running tasks have no duration set, so we can figure it out.
        if (!result.duration && result.state === this.RUNNING && result.started_ts){
          result.duration = (now - result.started_ts) / 1000;
        }
        // Make the duration human readable
        if (result.duration){
          result.human_duration = this._humanDuration(result.duration);
        }
        // result.bot_dimensions
        if (result.bot_dimensions) {
          result.bot_dimensions.forEach(function(dim){
            if (swarming.alias.has(dim.key)) {
              // dim.value is an array
              dim.value.forEach(function(v, i){
                dim.value[i] = swarming.alias.apply(v, dim.key);
              });
            }
          })
        }
        return result;
      },

      _parseStdout: function(stdout) {
        if (!stdout || !stdout.output) {
          return "";
        }
        return stdout.output;
      }

    });
  })();
  </script>
</dom-module>