<!--
  Copyright 2016 The LUCI Authors. All rights reserved.
  Use of this source code is governed under the Apache License, Version 2.0
  that can be found in the LICENSE file.

  This in an HTML Import-able file that contains the definition
  of the following elements:

    <bot-list-data>

  This makes calls authenticated with Oauth 2 to the swarming apis.  It parses
  that data into usable data structures.

  Usage:

    <bot-list-data></bot-list-data>

  Properties:
    // inputs
    auth_headers: Object, the OAuth2 header to include in the request.  This
        should come from swarming-app.
    query_params: Object, The query params that will filter the query
        server-side.  This can have dimensions:Array<String>, quarantined:String
        and is_dead: String. For example:
        {
          "dimensions": ["pool:Skia", "device_type:sprout"],
          "quarantined": "FALSE",  // optional
          "is_dead": "TRUE",       // optional
        }
        For a full list of dimensions in the fleet, see the API call:
        https://[swarming_url]/_ah/api/swarming/v1/bots/dimensions
    // outputs
    tasks: Array<Object>, all tasks returned by the server.

  Methods:
    signIn(): Force a signin of the user using OAuth.  This happens
        automatically when auth_headers is set.

  Events:
    None.
-->

<link rel="import" href="/res/imp/common/common-behavior.html">
<link rel="import" href="/res/imp/common/task-behavior.html">

<dom-module id="task-list-data">
  <script>
  (function(){
    var TIMES = ["abandoned_ts", "completed_ts", "created_ts", "modified_ts", "started_ts"];
    Polymer({
      is: 'task-list-data',

      behaviors: [
          SwarmingBehaviors.CommonBehavior,
          SwarmingBehaviors.TaskBehavior,
      ],

      properties: {
        // inputs
        auth_headers: {
          type: Object,
          observer: "signIn",
        },
        query_params: {
          type: Object,
          observer: "_request",
        },

        // outputs
        busy: {
          type: Boolean,
          computed: "_or(_busy1,_busy2,_busy3)",
          notify: true,
        },
        primary_map: {
          type: Object,
          computed: "_primaryMap(_tags,_dimensions,tasks)",
          notify: true,
        },
        primary_arr: {
          type: Array,
          computed: "_primaryArr(primary_map)",
          notify: true,
        },
        tasks: {
          type: Array,
          computed: "_tasks(_list)",
          notify: true,
        },

        // private
         _busy1: {
          type: Boolean,
          value: false
        },
        _busy2: {
          type: Boolean,
          value: false
        },
        _busy3: {
          type: Boolean,
          value: false
        },
        _dimensions: {
          type: Object,
        },
        _list: {
          type: Object,
        },
        _tags: {
          type: Object,
        },
      },

      signIn: function(){
        this._getJsonAsync("_tags", "/api/swarming/v1/tasks/tags",
          "_busy2", this.auth_headers);
        this._getJsonAsync("_dimensions","/api/swarming/v1/bots/dimensions",
          "_busy3", this.auth_headers);

        this._request();
      },

      _primaryArr: function(map) {
        var arr = Object.keys(map);
        arr.sort();
        return arr;
      },

      _primaryMap: function(tags, dims, tasks) {
        tags = (tags && tags.tasks_tags) || [];
        dims = (dims && dims.bots_dimensions) || [];
        tasks = tasks || [];
        var map = {};
        // We combine all the tags reported by the tags endpoint, all known
        // dimensions from the dimensions endpoint, and the tags seen in the
        // returned tasks, just in case they didn't show up in the first two.
        // This way a user can filter by what the data actually has and can
        // discover new tags to filter by.
        tags.forEach(function(t) {
          if (!map[t.key]) {
            map[t.key] = {};
          }
          var values = t.value || [];
          values.forEach(function(v) {
            map[t.key][v] = true;
          })
        });

        dims.forEach(function(d) {
          var vals = d.value;
          if (!map[d.key]) {
            map[d.key] = {};
          }
          vals.forEach(function(v) {
            map[d.key][v] = true;
          })
        });

        tasks.forEach(function(t) {
          Object.keys(t.tagMap).forEach(function(k) {
            var v = t.tagMap[k];
            if (!map[k]) {
              map[k] = {};
            }
            map[k][v] = true;
          });
        });

        // Turn the Map<Object,Map<Boolean>> into a Map<Object,Array<String>>
        // with all of the aliases applied.
        var pMap = {};
        for (key in map) {
          var values = Object.keys(map[key]);
          if (swarming.alias.DIMENSIONS_WITH_ALIASES.indexOf(key) === -1) {
            pMap[key] = values;
          } else {
            var aliased = [];
            values.forEach(function(value){
              aliased.push(swarming.alias.apply(value, key));
            });
            pMap[key] = aliased;
          }
        }

        // Add some options that might not show up.
        pMap["android_devices"].push("0");
        pMap["device_os"].push("none");
        pMap["device_type"].push("none");
        pMap["user"].push("none");

        // Custom filter options
        pMap["name"] = [];
        // Some of these are hard coded because the server expects something
        // like "DEDUPED" instead of the more human friendly
        // "COMPLETED (DEDUPED)"
        pMap["state"] = [this.PENDING, this.RUNNING, "PENDING_RUNNING", this.COMPLETED,
            "COMPLETED_SUCCESS", "COMPLETED_FAILURE", this.EXPIRED, this.TIMED_OUT,
            this.BOT_DIED, this.CANCELED, "DEDUPED", "ALL"];
        pMap["costs_usd"] = [];
        pMap["deduped_from"] = [];
        pMap["duration"] = [];
        pMap["server_versions"] = [];
        TIMES.forEach(function(t) {
          pMap[t] = [];
        });

        return pMap;
      },

      _request: function() {
        // wait until the user has logged in and the filters have loaded before requesting this to avoid double or even triple requests.
        if (!this.auth_headers || !this.query_params) {
          return;
        }
        this._getJsonAsync("_list", "/api/swarming/v1/tasks/list",
          "_busy1", this.auth_headers, this.query_params);
      },

      _tasks: function() {
        if (!this._list || !this._list.items) {
          return [];
        }
        var now = new Date();

        // Do any preprocessing here
        this._list.items.forEach(function(t) {
          var tagMap = {};
          t.tags = t.tags || [];
          t.tags.forEach(function(tag) {
            var split = tag.split(":", 1)
            var key = split[0];
            var rest = tag.substring(key.length + 1);
            tagMap[key] = rest;
          });
          t.tagMap = tagMap;

          TIMES.forEach(function(time) {
            if (t[time]) {
              t[time] = new Date(t[time]);
              t["human_"+time] = sk.human.localeTime(t[time]);
            }
          });
          // Running tasks have no duration set, so we can figure it out.
          if (!t.duration && t.state === this.RUNNING && t.started_ts){
            t.duration = (now - t.started_ts) / 1000;
          }
          // Make the duration human readable
          if (t.duration){
            t.human_duration = this._humanDuration(t.duration);
          }
        }.bind(this));
        return this._list.items;
      }
    });
  })();
  </script>
</dom-module>
